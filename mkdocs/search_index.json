{
    "docs": [
        {
            "location": "/", 
            "text": "Apprendre \u00e0 programmer\n#\n\n\nPr\u00e9face\n#\n\n\nTu m'as dit vouloir \u00ab apprendre \u00e0 coder \u00bb. Je t'ai dis que c'\u00e9tait possible en 5 jours. \nIl faut compter l'\u00e9quivalent de 30h tout compris (cours, exercices, r\u00e9visions).\n\n\nLorsque le moment s'y pr\u00eatera le mieux (ex: un matin \u00e0 partir de 7h), prends un stylo, un clavier, attache ta ceinture... c'est parti !", 
            "title": "Home"
        }, 
        {
            "location": "/#apprendre-a-programmer", 
            "text": "", 
            "title": "Apprendre \u00e0 programmer"
        }, 
        {
            "location": "/#preface", 
            "text": "Tu m'as dit vouloir \u00ab apprendre \u00e0 coder \u00bb. Je t'ai dis que c'\u00e9tait possible en 5 jours. \nIl faut compter l'\u00e9quivalent de 30h tout compris (cours, exercices, r\u00e9visions).  Lorsque le moment s'y pr\u00eatera le mieux (ex: un matin \u00e0 partir de 7h), prends un stylo, un clavier, attache ta ceinture... c'est parti !", 
            "title": "Pr\u00e9face"
        }, 
        {
            "location": "/chapitre-01-generalit\u00e9s/", 
            "text": "\ufeffApprendre \u00e0 coder\n#\n\n\nAlors donc tu veux apprendre \u00e0 programmer ?\n\n\nDans \u00ab programmer \u00bb il est important de distinguer deux aspects : \nl'ALGORITHMIQUE et les LANGAGES de programmation. \n\n\nL'ALGORITHMIQUE est un peu l'\u00e9quivalent de la logique pour formuler des id\u00e9es l\u00e0 ou les LANGAGES se basent chacun sur une syntaxe et une grammaire permettant de les v\u00e9hiculer et se faire comprendre. \n\n\n\u00c9videmment, on ne peut pas formuler d'id\u00e9es sans mots, et utiliser des mots sans id\u00e9es ne fonctionne pas tr\u00e8s bien non plus...\n\n\nPour re-situer dans le contexte : l'objectif de l'informatique, c'est obtenir de la machine qu'elle effectue un travail \u00e0 notre place (pour le meilleur et pour le pire...).\n\n\nLe probl\u00e8me : comment lui expliquer comment elle doit s'y prendre ? Comment lui dire ? Comment lui apprendre ? Comment s'assurer qu'elle fait ce travail ? Et si on y arrive... fera-t-elle ce travail aussi bien que nous ? Mieux que nous ?\n\n\nBref. Dans ce qui suit, je vais donc te faire une introduction \u00e0 la programmation en plusieurs \u00e9tapes : \n- d'abord nous ferons des dessins, \n- ensuite nous en utilisant le langage parl\u00e9, en fran\u00e7ais, pour d\u00e9crire nos id\u00e9es,\n- ensuite nous utiliserons JavaScript pour communiquer ces id\u00e9es \u00e0 l'ordinateur.\n\n\nPourquoi Javascript ? Parce que : \n- c'est un langage que l'on retrouve partout : front-end web, applications mobiles traitements m\u00e9tier sur les serveurs et depuis peu dans l'embarqu\u00e9 !\n- c'est un langage \u00e0 la mode : il y a de la demande pour du web et des app mobiles, les gens paient pour \u00e7a, la technologie \u00e9volue et se bonnifie,\n- c'est un langage facile \u00e0 apprendre !\n\n\nAlgori...quoi ?\n#\n\n\nAlgorithmes. Algorithmique. Algorithmie.\n\n\nSans le savoir tu en as d\u00e9j\u00e0 utilis\u00e9 :\n\n\n\n\ndes briques de LEGO(tm) pour faire une caserne de pompiers\n\n\ndes planches et des vis pour monter une \u00e9tag\u00e8re BILLY(c) IKEA(tm)\n\n\ndes ingr\u00e9dients pour faire un gateau\n\n\n\n\nDans tout ces cas l\u00e0, tu as suivi un plan, un guide de montage, une recette. Tu \u00e9tais dans une posture d'\u00e9xecution, qui t'a permis de \"suivre\" le travail imagin\u00e9 par quelqu'un d'autre afin de le reproduire.\n\n\nCependant, ceux qui ont con\u00e7u cette caserne de pompier, cette \u00e9tag\u00e8re BILLY(c) IKEA(tm), ce gateau... comment ont-il proc\u00e9d\u00e9 ? Quelle \u00e9tait la d\u00e9marche qui leur a permis, tout d'abord d'inventer un objet r\u00e9pondant \u00e0 leur besoin, ensuite de d\u00e9composer leur id\u00e9e, et enfin d'expliquer les \u00e9tapes n\u00e9cessaire \u00e0 sa r\u00e9alisation ?\n\n\nAu d\u00e9part on avait des composants ou des ingr\u00e9dients \u00e9parses,  ils ont \u00e9t\u00e9 assembl\u00e9s dans un certain ordre et d'une certaine fa\u00e7on, afin d'obtenir un r\u00e9sultat souhait\u00e9. \n\n\nCette d\u00e9marche de r\u00e9solution de probl\u00e8mes et cette m\u00e9thodologie pour les d\u00e9composer en \u00e9tapes simples, c'est ce qu'en informatique on appele l'algorithmique. Evidemment \u00e7a peut s'appliquer \u00e0 bien d'autres sujets !\n\n\nUne question d'\u00e9criture et de repr\u00e9sentations\n#\n\n\nPuisque dans un algorithme on trouve simplement des \u00e9tapes et des actions, il peut avoir plusieurs repr\u00e9sentations  : \n\n\n\n\nun \nalgorigramme\n : un diagramme d'\u00e9tapes successives repr\u00e9sent\u00e9 avec des rectangles, des bulles, des losanges et des fleches, \n\n\ndu \npseudo-code\n : une \u00e9criture en quasi-fran\u00e7ais d\u00e9sambigu\u00e9\n\n\ndu \ncode source\n : une explication dans un langage informatique non-ambig\u00fc permettant \u00e0 l'ordinateur de le transformer en quelque chose qu'il comprends.\n\n\ndu \nbyte-code\n : suite d'instructions binaires pour un logiciel interpr\u00eate\n\n\ndu \ncode machine\n : suite d'instructions binaires envoy\u00e9es au processeur et \u00e0 la m\u00e9moire.\n\n\n\n\nL'algorigramme et le pseudo-code sont l\u00e0 essentiellement pour des besoins \u00e9ducatifs, mais il existe d'autres formes de diagrammes qui sont \"normalis\u00e9s\" et permettent \u00e9galement de repr\u00e9senter des programmes. On parlera alors de repr\u00e9sentation UML, Merise, SDL, etc. Ces diff\u00e9rents langages graphiques  permettent d'avoir une description et d'organiser un projet informatique entre plusieurs intervenants de m\u00e9tiers diff\u00e9rents et leur permettre de communiquer.\n\n\nLe code machine (ou binaire executable) c'est ce que la machine comprends \"en vrai\", c'est la suite d'op\u00e9rations que le processeur doit faire, et les diff\u00e9rents \u00e9tats de la m\u00e9moire \u00e0 lui faire manipuler. Ce code machine est sp\u00e9cifique \u00e0 un mod\u00e8le de processeur donn\u00e9 (et incompatible avec un autre mod\u00e8le de processeur). C'est pourtant de cette fa\u00e7on l\u00e0 qu'il faut \u00e9crire le premier programme sur un processeur donn\u00e9, afin qu'il s'allume et serve \u00e0 quelque chose.\n\n\nM\u00eame si c'est encore possible (et qu'on l'a beaucoup fait par le pass\u00e9), c'est assez ingrat d'\u00e9crire un programme de cette fa\u00e7on !\n\n\nAssez rapidement, face au code machine, on s'est rendu compte qu'il \u00e9tait plus pratique d'\u00e9crire des programmes appel\u00e9s des compilateurs : c'est \u00e0 dire des outils capables de prendre un programme \u00e9crit dans un langage de programmation (\u00e9crit par un humain) et de le transcrire automatiquement en code machine, pour obtenir un binaire ex\u00e9cutable sans l'\u00e9crire soi-m\u00eame en code machine. On a donc fabriqu\u00e9 un compilateur par langage de programmation et par type de machine.\n\n\nIl faut savoir que lorsqu'on a du code machine entre les mains, c'est tr\u00e8s compliqu\u00e9 (voire impossible) de revenir au code source de d\u00e9part... c'est comme essayer de retrouver les ingr\u00e9dients et le dosage pr\u00e9cis d'un plat rien qu'en le goutant ! Il faut \u00eatre expert gouteur, expert cuisinier... et l\u00e0 encore, c'est dur ! Cette propri\u00e9t\u00e9 du code machine est \u00e9videmment une aubaine pour les gens qui veulent diffuser leur programme sans montrer son fonctionnement.\n\n\nMalgr\u00e9 cela, il y a un hic ! L'auteur (ou l'\u00e9diteur) doivent compiler leur code source en binaire ex\u00e9cutable pour chaque nouvelle plate-forme mat\u00e9rielle qui voit le jour, sous peine de voit leur programme \u00eatre incompatible chez les usagers des nouvelles plates-formes ! Et \u00e7a n\u00e9cessite donc beaucoup de travail (et donc des co\u00fbts) !\n\n\nL\u00e0 encore, des petits malins se sont dit qu'il \u00e9tait peut-\u00eatre plus pratique d'avoir un \"interpr\u00eate\" (ou interpr\u00e9teur), c'est \u00e0 dire un programme binaire sp\u00e9cifique \u00e0 chaque machine, capable de lire du code source et de le transformer au fur et en instructionss pour le processeur. Ainsi, plus besoin de compilation, et le programme est compatible avec toutes les machines o\u00f9 se trouve un interpr\u00e9teur pour le langage dans lequel il est \u00e9crit ! \n\n\nMalheureusement, il y a deux soucis avec les int\u00e9rpr\u00e9teurs : transcrire \"\u00e0 la vol\u00e9e\" du code source, cela n\u00e9cessite du temps... Par cons\u00e9quent un interpr\u00e9te sera donc toujours plus lent qu'un programme binaire ex\u00e9cutable. En plus, pour utiliser un programme avec un interpr\u00eateur il faut diffuser le code source du programme ! Autant \u00e7a ne g\u00e8ne pas les adeptes du partage, autant les gens voulant garder secrets leurs algorithmes n'ont pas trouv\u00e9 cela g\u00e9nial...\n\n\nC'est l\u00e0 qu'est apparu le byte-code. Le byte-code, c'est du code machine pour une machine \"virtuelle\", c'est \u00e0 dire une machine qui n'existe pas mais dont le code machine hypoth\u00e9tique serait minimaliste et transposable facilement sur n'importe quel processeur, avec moins d'efforts que pour un langage de programmation. L'id\u00e9e est ici de compiler quand le code source en du byte-code, et d'avoir un interpr\u00e9teur de byte-code sur chaque plate-forme. \n\n\nAvec cette technique, on obtient une vitesse de fonctionnement raisonnable, une compatibilit\u00e9 avec toutes les machines qui poss\u00e8dent un interpr\u00e9teur bytecode et aucune fa\u00e7on de remonter au code source de d\u00e9part ! C'est la strat\u00e9gie utilis\u00e9e par Java ou .NET . \n\n\nBref. Lorsque l'on programme, on \u00e9crit donc en g\u00e9n\u00e9ral du code source, dans un langage de programmation. Mais rien n'empeche de faire un diagramme pour se fixer les id\u00e9es ! \u00c7a arrive m\u00eame aux meilleurs professionels apr\u00e8s plusieurs d\u00e9c\u00e9nies de pratique.\n\n\nA suivre ?\n#\n\n\nAvant de continuer, j'ai besoin d'en savoir plus sur toi ! D\u00e9j\u00e0 parce que je suis curieux (eh oui!) et parce que \u00e7a me permettra d'adapter sur-mesure la suite du cours :\n- pourquoi est-ce que la technologie t'int\u00e9resse ? \n- comment est-ce que tu imagines le fait de coder ? \n- qu'est ce que tu imagines que cela peut t'apporter ?\n\n\nBref. Si tu veux la suite, r\u00e9ponds \"JE VEUX LA SUITE !\" \u00e0 cet email :-)", 
            "title": "Chapitre 01 generalit\u00e9s"
        }, 
        {
            "location": "/chapitre-01-generalit\u00e9s/#apprendre-a-coder", 
            "text": "Alors donc tu veux apprendre \u00e0 programmer ?  Dans \u00ab programmer \u00bb il est important de distinguer deux aspects : \nl'ALGORITHMIQUE et les LANGAGES de programmation.   L'ALGORITHMIQUE est un peu l'\u00e9quivalent de la logique pour formuler des id\u00e9es l\u00e0 ou les LANGAGES se basent chacun sur une syntaxe et une grammaire permettant de les v\u00e9hiculer et se faire comprendre.   \u00c9videmment, on ne peut pas formuler d'id\u00e9es sans mots, et utiliser des mots sans id\u00e9es ne fonctionne pas tr\u00e8s bien non plus...  Pour re-situer dans le contexte : l'objectif de l'informatique, c'est obtenir de la machine qu'elle effectue un travail \u00e0 notre place (pour le meilleur et pour le pire...).  Le probl\u00e8me : comment lui expliquer comment elle doit s'y prendre ? Comment lui dire ? Comment lui apprendre ? Comment s'assurer qu'elle fait ce travail ? Et si on y arrive... fera-t-elle ce travail aussi bien que nous ? Mieux que nous ?  Bref. Dans ce qui suit, je vais donc te faire une introduction \u00e0 la programmation en plusieurs \u00e9tapes : \n- d'abord nous ferons des dessins, \n- ensuite nous en utilisant le langage parl\u00e9, en fran\u00e7ais, pour d\u00e9crire nos id\u00e9es,\n- ensuite nous utiliserons JavaScript pour communiquer ces id\u00e9es \u00e0 l'ordinateur.  Pourquoi Javascript ? Parce que : \n- c'est un langage que l'on retrouve partout : front-end web, applications mobiles traitements m\u00e9tier sur les serveurs et depuis peu dans l'embarqu\u00e9 !\n- c'est un langage \u00e0 la mode : il y a de la demande pour du web et des app mobiles, les gens paient pour \u00e7a, la technologie \u00e9volue et se bonnifie,\n- c'est un langage facile \u00e0 apprendre !", 
            "title": "\ufeffApprendre \u00e0 coder"
        }, 
        {
            "location": "/chapitre-01-generalit\u00e9s/#algoriquoi", 
            "text": "Algorithmes. Algorithmique. Algorithmie.  Sans le savoir tu en as d\u00e9j\u00e0 utilis\u00e9 :   des briques de LEGO(tm) pour faire une caserne de pompiers  des planches et des vis pour monter une \u00e9tag\u00e8re BILLY(c) IKEA(tm)  des ingr\u00e9dients pour faire un gateau   Dans tout ces cas l\u00e0, tu as suivi un plan, un guide de montage, une recette. Tu \u00e9tais dans une posture d'\u00e9xecution, qui t'a permis de \"suivre\" le travail imagin\u00e9 par quelqu'un d'autre afin de le reproduire.  Cependant, ceux qui ont con\u00e7u cette caserne de pompier, cette \u00e9tag\u00e8re BILLY(c) IKEA(tm), ce gateau... comment ont-il proc\u00e9d\u00e9 ? Quelle \u00e9tait la d\u00e9marche qui leur a permis, tout d'abord d'inventer un objet r\u00e9pondant \u00e0 leur besoin, ensuite de d\u00e9composer leur id\u00e9e, et enfin d'expliquer les \u00e9tapes n\u00e9cessaire \u00e0 sa r\u00e9alisation ?  Au d\u00e9part on avait des composants ou des ingr\u00e9dients \u00e9parses,  ils ont \u00e9t\u00e9 assembl\u00e9s dans un certain ordre et d'une certaine fa\u00e7on, afin d'obtenir un r\u00e9sultat souhait\u00e9.   Cette d\u00e9marche de r\u00e9solution de probl\u00e8mes et cette m\u00e9thodologie pour les d\u00e9composer en \u00e9tapes simples, c'est ce qu'en informatique on appele l'algorithmique. Evidemment \u00e7a peut s'appliquer \u00e0 bien d'autres sujets !", 
            "title": "Algori...quoi ?"
        }, 
        {
            "location": "/chapitre-01-generalit\u00e9s/#une-question-decriture-et-de-representations", 
            "text": "Puisque dans un algorithme on trouve simplement des \u00e9tapes et des actions, il peut avoir plusieurs repr\u00e9sentations  :    un  algorigramme  : un diagramme d'\u00e9tapes successives repr\u00e9sent\u00e9 avec des rectangles, des bulles, des losanges et des fleches,   du  pseudo-code  : une \u00e9criture en quasi-fran\u00e7ais d\u00e9sambigu\u00e9  du  code source  : une explication dans un langage informatique non-ambig\u00fc permettant \u00e0 l'ordinateur de le transformer en quelque chose qu'il comprends.  du  byte-code  : suite d'instructions binaires pour un logiciel interpr\u00eate  du  code machine  : suite d'instructions binaires envoy\u00e9es au processeur et \u00e0 la m\u00e9moire.   L'algorigramme et le pseudo-code sont l\u00e0 essentiellement pour des besoins \u00e9ducatifs, mais il existe d'autres formes de diagrammes qui sont \"normalis\u00e9s\" et permettent \u00e9galement de repr\u00e9senter des programmes. On parlera alors de repr\u00e9sentation UML, Merise, SDL, etc. Ces diff\u00e9rents langages graphiques  permettent d'avoir une description et d'organiser un projet informatique entre plusieurs intervenants de m\u00e9tiers diff\u00e9rents et leur permettre de communiquer.  Le code machine (ou binaire executable) c'est ce que la machine comprends \"en vrai\", c'est la suite d'op\u00e9rations que le processeur doit faire, et les diff\u00e9rents \u00e9tats de la m\u00e9moire \u00e0 lui faire manipuler. Ce code machine est sp\u00e9cifique \u00e0 un mod\u00e8le de processeur donn\u00e9 (et incompatible avec un autre mod\u00e8le de processeur). C'est pourtant de cette fa\u00e7on l\u00e0 qu'il faut \u00e9crire le premier programme sur un processeur donn\u00e9, afin qu'il s'allume et serve \u00e0 quelque chose.  M\u00eame si c'est encore possible (et qu'on l'a beaucoup fait par le pass\u00e9), c'est assez ingrat d'\u00e9crire un programme de cette fa\u00e7on !  Assez rapidement, face au code machine, on s'est rendu compte qu'il \u00e9tait plus pratique d'\u00e9crire des programmes appel\u00e9s des compilateurs : c'est \u00e0 dire des outils capables de prendre un programme \u00e9crit dans un langage de programmation (\u00e9crit par un humain) et de le transcrire automatiquement en code machine, pour obtenir un binaire ex\u00e9cutable sans l'\u00e9crire soi-m\u00eame en code machine. On a donc fabriqu\u00e9 un compilateur par langage de programmation et par type de machine.  Il faut savoir que lorsqu'on a du code machine entre les mains, c'est tr\u00e8s compliqu\u00e9 (voire impossible) de revenir au code source de d\u00e9part... c'est comme essayer de retrouver les ingr\u00e9dients et le dosage pr\u00e9cis d'un plat rien qu'en le goutant ! Il faut \u00eatre expert gouteur, expert cuisinier... et l\u00e0 encore, c'est dur ! Cette propri\u00e9t\u00e9 du code machine est \u00e9videmment une aubaine pour les gens qui veulent diffuser leur programme sans montrer son fonctionnement.  Malgr\u00e9 cela, il y a un hic ! L'auteur (ou l'\u00e9diteur) doivent compiler leur code source en binaire ex\u00e9cutable pour chaque nouvelle plate-forme mat\u00e9rielle qui voit le jour, sous peine de voit leur programme \u00eatre incompatible chez les usagers des nouvelles plates-formes ! Et \u00e7a n\u00e9cessite donc beaucoup de travail (et donc des co\u00fbts) !  L\u00e0 encore, des petits malins se sont dit qu'il \u00e9tait peut-\u00eatre plus pratique d'avoir un \"interpr\u00eate\" (ou interpr\u00e9teur), c'est \u00e0 dire un programme binaire sp\u00e9cifique \u00e0 chaque machine, capable de lire du code source et de le transformer au fur et en instructionss pour le processeur. Ainsi, plus besoin de compilation, et le programme est compatible avec toutes les machines o\u00f9 se trouve un interpr\u00e9teur pour le langage dans lequel il est \u00e9crit !   Malheureusement, il y a deux soucis avec les int\u00e9rpr\u00e9teurs : transcrire \"\u00e0 la vol\u00e9e\" du code source, cela n\u00e9cessite du temps... Par cons\u00e9quent un interpr\u00e9te sera donc toujours plus lent qu'un programme binaire ex\u00e9cutable. En plus, pour utiliser un programme avec un interpr\u00eateur il faut diffuser le code source du programme ! Autant \u00e7a ne g\u00e8ne pas les adeptes du partage, autant les gens voulant garder secrets leurs algorithmes n'ont pas trouv\u00e9 cela g\u00e9nial...  C'est l\u00e0 qu'est apparu le byte-code. Le byte-code, c'est du code machine pour une machine \"virtuelle\", c'est \u00e0 dire une machine qui n'existe pas mais dont le code machine hypoth\u00e9tique serait minimaliste et transposable facilement sur n'importe quel processeur, avec moins d'efforts que pour un langage de programmation. L'id\u00e9e est ici de compiler quand le code source en du byte-code, et d'avoir un interpr\u00e9teur de byte-code sur chaque plate-forme.   Avec cette technique, on obtient une vitesse de fonctionnement raisonnable, une compatibilit\u00e9 avec toutes les machines qui poss\u00e8dent un interpr\u00e9teur bytecode et aucune fa\u00e7on de remonter au code source de d\u00e9part ! C'est la strat\u00e9gie utilis\u00e9e par Java ou .NET .   Bref. Lorsque l'on programme, on \u00e9crit donc en g\u00e9n\u00e9ral du code source, dans un langage de programmation. Mais rien n'empeche de faire un diagramme pour se fixer les id\u00e9es ! \u00c7a arrive m\u00eame aux meilleurs professionels apr\u00e8s plusieurs d\u00e9c\u00e9nies de pratique.", 
            "title": "Une question d'\u00e9criture et de repr\u00e9sentations"
        }, 
        {
            "location": "/chapitre-01-generalit\u00e9s/#a-suivre", 
            "text": "Avant de continuer, j'ai besoin d'en savoir plus sur toi ! D\u00e9j\u00e0 parce que je suis curieux (eh oui!) et parce que \u00e7a me permettra d'adapter sur-mesure la suite du cours :\n- pourquoi est-ce que la technologie t'int\u00e9resse ? \n- comment est-ce que tu imagines le fait de coder ? \n- qu'est ce que tu imagines que cela peut t'apporter ?  Bref. Si tu veux la suite, r\u00e9ponds \"JE VEUX LA SUITE !\" \u00e0 cet email :-)", 
            "title": "A suivre ?"
        }
    ]
}