{
    "docs": [
        {
            "location": "/", 
            "text": "Apprendre \u00e0 programmer\n#\n\n\nPr\u00e9face\n#\n\n\nTu m'as dit vouloir \u00ab apprendre \u00e0 coder \u00bb. Je t'ai dis que c'\u00e9tait possible en 5 jours. \nIl faut compter l'\u00e9quivalent de 30h tout compris (cours, exercices, r\u00e9visions).\n\n\nLorsque le moment s'y pr\u00eatera le mieux (ex: un matin \u00e0 partir de 7h), prends un stylo, un clavier, attache ta ceinture... c'est parti !", 
            "title": "Accueil"
        }, 
        {
            "location": "/#apprendre-a-programmer", 
            "text": "", 
            "title": "Apprendre \u00e0 programmer"
        }, 
        {
            "location": "/#preface", 
            "text": "Tu m'as dit vouloir \u00ab apprendre \u00e0 coder \u00bb. Je t'ai dis que c'\u00e9tait possible en 5 jours. \nIl faut compter l'\u00e9quivalent de 30h tout compris (cours, exercices, r\u00e9visions).  Lorsque le moment s'y pr\u00eatera le mieux (ex: un matin \u00e0 partir de 7h), prends un stylo, un clavier, attache ta ceinture... c'est parti !", 
            "title": "Pr\u00e9face"
        }, 
        {
            "location": "/01-generalites/", 
            "text": "\ufeffG\u00e9n\u00e9ralit\u00e9s\n#\n\n\nQuelques d\u00e9finitions\n#\n\n\nBon, donc tu veux \nvraiment\n apprendre \u00e0 programmer ?\n\n\nDans \u00ab programmer \u00bb il est important de distinguer deux aspects : \n\nl'algorithmique\n et les \nlangages\n de programmation. \n\n\nL'algorithmique\n est un peu l'\u00e9quivalent de la logique pour formuler des id\u00e9es l\u00e0 ou les \nlangages\n se basent chacun sur une syntaxe et une grammaire permettant de les v\u00e9hiculer et se faire comprendre. \n\u00c9videmment, on ne peut pas formuler d'id\u00e9es sans mots, et utiliser des mots sans id\u00e9es ne fonctionne pas tr\u00e8s bien non plus...\n\n\nRe-situons tout \u00e7a dans le contexte : l'objectif de l'informatique, c'est obtenir de la machine qu'elle effectue un travail \u00e0 notre place (pour le meilleur et pour le pire...). Mais alors, comment lui expliquer comment elle doit s'y prendre ? Comment lui dire ? Comment lui apprendre ? Comment s'assurer qu'elle fait ce travail ? Et si on y arrive... fera-t-elle ce travail aussi bien que nous ? Mieux que nous ?\n\n\nBref. Dans ce qui suit, je vais donc te faire une introduction \u00e0 la programmation en plusieurs \u00e9tapes : \n\n\n\n\nd'abord nous ferons des dessins, \n\n\nensuite nous utiliserons une forme de fran\u00e7ais minimaliste pour d\u00e9crire nos id\u00e9es,\n\n\nensuite nous utiliserons JavaScript pour communiquer ces id\u00e9es \u00e0 l'ordinateur.\n\n\n\n\nPourquoi Javascript ? Parce que : \n\n\n\n\nc'est un langage que l'on retrouve partout : front-end web, applications mobiles traitements m\u00e9tier sur les serveurs et depuis peu dans l'embarqu\u00e9 !\n\n\nc'est un langage \u00e0 la mode : il y a de la demande pour du web et des app mobiles, les gens paient pour \u00e7a, la technologie \u00e9volue et se bonnifie,\n\n\nc'est un langage facile \u00e0 apprendre !\n\n\n\n\nAlgori...quoi ?\n#\n\n\nAlgorithmes. Algorithmique. Algorithmie.\n\n\nSans le savoir tu en as d\u00e9j\u00e0 utilis\u00e9 :\n\n\n\n\ndes briques de LEGO\n pour faire une caserne de pompiers\n\n\ndes planches et des vis pour monter une \u00e9tag\u00e8re BILLY\n IKEA\n\n\ndes ingr\u00e9dients pour faire un g\u00e2teau\n\n\n\n\nDans tout ces cas l\u00e0, tu as suivi un plan, un guide de montage, une recette. Tu \u00e9tais dans une posture d'ex\u00e9cution, qui t'a permis de \"suivre\" le travail imagin\u00e9 par quelqu'un d'autre afin de le reproduire.\n\n\nCependant, ceux qui ont con\u00e7u cette caserne de pompier, cette \u00e9tag\u00e8re BILLY\n IKEA\n, ce g\u00e2teau... comment ont-il proc\u00e9d\u00e9 ? Quelle \u00e9tait la d\u00e9marche qui leur a permis, tout d'abord \nd'inventer\n un objet r\u00e9pondant \u00e0 leur besoin, ensuite de \nd\u00e9composer\n leur id\u00e9e, et enfin \nd'expliquer\n les \u00e9tapes n\u00e9cessaire \u00e0 sa r\u00e9alisation ?\n\n\nAu d\u00e9part on avait des composants ou des ingr\u00e9dients \u00e9parses,  ils ont \u00e9t\u00e9 assembl\u00e9s dans un certain ordre et d'une certaine fa\u00e7on, afin d'obtenir un r\u00e9sultat souhait\u00e9. Cette d\u00e9marche de r\u00e9solution de probl\u00e8mes et cette m\u00e9thodologie pour les d\u00e9composer en \u00e9tapes simples, c'est ce qu'en informatique on appelle l'algorithmique. \u00c9videmment \u00e7a peut s'appliquer \u00e0 bien d'autres sujets !\n\n\nUne question d'\u00e9criture et de repr\u00e9sentations\n#\n\n\nPuisque dans un algorithme on trouve simplement des \u00e9tapes et des actions, il peut avoir plusieurs repr\u00e9sentations  : \n\n\n\n\nun \nalgorigramme\n : un diagramme d'\u00e9tapes successives repr\u00e9sent\u00e9 avec des rectangles, des bulles, des losanges et des fl\u00e8ches, \n\n\ndu \npseudo-code\n : une \u00e9criture en quasi-fran\u00e7ais d\u00e9sambigu\u00efs\u00e9\n\n\ndu \ncode source\n : une explication dans un langage informatique non-ambig\u00fc permettant \u00e0 l'ordinateur de le transformer en quelque chose qu'il comprends.\n\n\ndu \nbyte-code\n : suite d'instructions binaires pour un logiciel interpr\u00e8te\n\n\ndu \ncode machine\n : suite d'instructions binaires envoy\u00e9es au processeur et \u00e0 la m\u00e9moire.\n\n\n\n\nL'algorigramme\n et le \npseudo-code\n sont l\u00e0 essentiellement pour des besoins \u00e9ducatifs, mais il existe d'autres formes de diagrammes qui sont \"normalis\u00e9s\" et permettent \u00e9galement de repr\u00e9senter des programmes. On parlera alors de repr\u00e9sentation UML, Merise, SDL, etc. Ces diff\u00e9rents langages graphiques  permettent d'avoir une description et d'organiser un projet informatique entre plusieurs intervenants de m\u00e9tiers diff\u00e9rents et leur permettre de communiquer.\n\n\nLe \ncode machine\n (ou binaire ex\u00e9cutable) c'est ce que la machine comprends \"en vrai\": c'est la suite d'op\u00e9rations que le processeur doit faire, et les diff\u00e9rents \u00e9tats de la m\u00e9moire \u00e0 lui faire manipuler.\n\nCe code machine est sp\u00e9cifique \u00e0 un mod\u00e8le de processeur donn\u00e9. Il est donc incompatible avec un autre mod\u00e8le de processeur!\n\n\nAssez vite on se rend compte que c'est assez ingrat d'\u00e9crire un programme de cette fa\u00e7on l\u00e0 ! C'est pourtant comme cela qu'il faut \u00e9crire le premier programme sur un processeur donn\u00e9, afin qu'il s'allume et serve \u00e0 quelque chose. \n\n\nPour \u00e9viter d'avoir \u00e0 faire cela pour tout le reste des programmes, on invent\u00e9 les \ncompilateurs\n : c'est \u00e0 dire des outils capables de prendre un autre programme, \u00e9crit dans un langage de programmation par un humain, et de les transcrire automatiquement en code machine, pour obtenir des binaires ex\u00e9cutables sans avoir \u00e0 les \u00e9crire soi-m\u00eame en code machine. On a donc du fabriquer un compilateur par langage de programmation... et par type de machine.\n\n\nIl faut savoir que lorsqu'on a du code machine entre les mains, c'est tr\u00e8s compliqu\u00e9 (voire impossible) de revenir au code source de d\u00e9part... c'est comme essayer de retrouver les ingr\u00e9dients et le dosage pr\u00e9cis d'un plat rien qu'en le go\u00fbtant ! Il faut \u00eatre expert go\u00fbteur, expert cuisinier... et l\u00e0 encore, c'est dur ! Cette propri\u00e9t\u00e9 du code machine est \u00e9videmment une aubaine pour les gens qui veulent diffuser leur programme sans montrer son fonctionnement.\n\n\nMalgr\u00e9 cela, il y a un hic ! L'auteur (ou l'\u00e9diteur) doivent compiler leur code source en binaire ex\u00e9cutable pour chaque nouvelle plate-forme mat\u00e9rielle qui voit le jour, sous peine de voit leur programme \u00eatre incompatible chez les usagers des nouvelles plates-formes ! Et \u00e7a n\u00e9cessite donc beaucoup de travail (et donc des co\u00fbts) !\n\n\nL\u00e0 encore, des petits malins se sont dit qu'il \u00e9tait peut-\u00eatre plus pratique d'avoir un \"interpr\u00e8te\" ou \ninterpr\u00e9teur\n, c'est \u00e0 dire un programme binaire sp\u00e9cifique \u00e0 chaque machine, capable de lire du code source et de le transformer au fur et \u00e0 mesure en instructions pour le processeur. Ainsi, plus besoin de compilation, et le programme est compatible avec toutes les machines o\u00f9 se trouve un interpr\u00e9teur pour le langage dans lequel il est \u00e9crit ! \n\n\nMalheureusement, il y a deux soucis avec les interpr\u00e9teurs : transcrire \"\u00e0 la vol\u00e9e\" du code source, cela n\u00e9cessite du temps... Par cons\u00e9quent un interpr\u00e8te sera donc toujours plus lent qu'un programme binaire ex\u00e9cutable. En plus, pour utiliser un programme avec un interpr\u00e9teur il faut diffuser le code source du programme ! Autant \u00e7a ne g\u00e8ne pas les adeptes du partage, autant les gens voulant garder secrets leurs algorithmes n'ont pas trouv\u00e9 cela g\u00e9nial...\n\n\nC'est l\u00e0 qu'est apparu le \nbyte-code\n. Le byte-code, c'est du code machine pour une machine \"virtuelle\", c'est \u00e0 dire une machine qui n'existe pas. Son code machine hypoth\u00e9tique serait minimaliste et transposable facilement sur n'importe quel processeur, avec moins d'efforts que pour un langage de programmation. L'id\u00e9e est ici de compiler quand le code source en du byte-code, et d'avoir un interpr\u00e9teur de byte-code sur chaque plate-forme. \n\n\nAvec cette technique, on obtient une vitesse de fonctionnement raisonnable, une compatibilit\u00e9 avec toutes les machines qui poss\u00e8dent un interpr\u00e9teur bytecode et aucune fa\u00e7on de remonter au code source de d\u00e9part ! C'est la strat\u00e9gie utilis\u00e9e par Java ou .NET . \n\n\nBref. Lorsque l'on programme, on \u00e9crit donc en g\u00e9n\u00e9ral du \ncode source\n, dans un langage de programmation. Mais rien n'emp\u00eache de faire un diagramme pour se fixer les id\u00e9es ! \u00c7a arrive m\u00eame aux meilleurs professionnels apr\u00e8s plusieurs d\u00e9c\u00e9nies de pratique.\n\n\n\u00c0 suivre ?\n#\n\n\nAvant de continuer, j'ai besoin d'en savoir plus sur toi ! D\u00e9j\u00e0 parce que je suis curieux (eh oui !) et parce que \u00e7a me permettra d'adapter sur-mesure la suite du cours :\n\n\n\n\npourquoi est-ce que la technologie t'int\u00e9resse ? \n\n\ncomment est-ce que tu imagines le fait de coder ? \n\n\nqu'est ce que tu imagines que cela peut t'apporter ?\n\n\n\n\nBref. Si tu veux la suite, envoie-moi un email avec le texte \n\"JE VEUX LA SUITE !\"\n dedans :-)", 
            "title": "01. G\u00e9n\u00e9ralit\u00e9s"
        }, 
        {
            "location": "/01-generalites/#generalites", 
            "text": "", 
            "title": "\ufeffG\u00e9n\u00e9ralit\u00e9s"
        }, 
        {
            "location": "/01-generalites/#quelques-definitions", 
            "text": "Bon, donc tu veux  vraiment  apprendre \u00e0 programmer ?  Dans \u00ab programmer \u00bb il est important de distinguer deux aspects :  l'algorithmique  et les  langages  de programmation.   L'algorithmique  est un peu l'\u00e9quivalent de la logique pour formuler des id\u00e9es l\u00e0 ou les  langages  se basent chacun sur une syntaxe et une grammaire permettant de les v\u00e9hiculer et se faire comprendre. \n\u00c9videmment, on ne peut pas formuler d'id\u00e9es sans mots, et utiliser des mots sans id\u00e9es ne fonctionne pas tr\u00e8s bien non plus...  Re-situons tout \u00e7a dans le contexte : l'objectif de l'informatique, c'est obtenir de la machine qu'elle effectue un travail \u00e0 notre place (pour le meilleur et pour le pire...). Mais alors, comment lui expliquer comment elle doit s'y prendre ? Comment lui dire ? Comment lui apprendre ? Comment s'assurer qu'elle fait ce travail ? Et si on y arrive... fera-t-elle ce travail aussi bien que nous ? Mieux que nous ?  Bref. Dans ce qui suit, je vais donc te faire une introduction \u00e0 la programmation en plusieurs \u00e9tapes :    d'abord nous ferons des dessins,   ensuite nous utiliserons une forme de fran\u00e7ais minimaliste pour d\u00e9crire nos id\u00e9es,  ensuite nous utiliserons JavaScript pour communiquer ces id\u00e9es \u00e0 l'ordinateur.   Pourquoi Javascript ? Parce que :    c'est un langage que l'on retrouve partout : front-end web, applications mobiles traitements m\u00e9tier sur les serveurs et depuis peu dans l'embarqu\u00e9 !  c'est un langage \u00e0 la mode : il y a de la demande pour du web et des app mobiles, les gens paient pour \u00e7a, la technologie \u00e9volue et se bonnifie,  c'est un langage facile \u00e0 apprendre !", 
            "title": "Quelques d\u00e9finitions"
        }, 
        {
            "location": "/01-generalites/#algoriquoi", 
            "text": "Algorithmes. Algorithmique. Algorithmie.  Sans le savoir tu en as d\u00e9j\u00e0 utilis\u00e9 :   des briques de LEGO  pour faire une caserne de pompiers  des planches et des vis pour monter une \u00e9tag\u00e8re BILLY  IKEA  des ingr\u00e9dients pour faire un g\u00e2teau   Dans tout ces cas l\u00e0, tu as suivi un plan, un guide de montage, une recette. Tu \u00e9tais dans une posture d'ex\u00e9cution, qui t'a permis de \"suivre\" le travail imagin\u00e9 par quelqu'un d'autre afin de le reproduire.  Cependant, ceux qui ont con\u00e7u cette caserne de pompier, cette \u00e9tag\u00e8re BILLY  IKEA , ce g\u00e2teau... comment ont-il proc\u00e9d\u00e9 ? Quelle \u00e9tait la d\u00e9marche qui leur a permis, tout d'abord  d'inventer  un objet r\u00e9pondant \u00e0 leur besoin, ensuite de  d\u00e9composer  leur id\u00e9e, et enfin  d'expliquer  les \u00e9tapes n\u00e9cessaire \u00e0 sa r\u00e9alisation ?  Au d\u00e9part on avait des composants ou des ingr\u00e9dients \u00e9parses,  ils ont \u00e9t\u00e9 assembl\u00e9s dans un certain ordre et d'une certaine fa\u00e7on, afin d'obtenir un r\u00e9sultat souhait\u00e9. Cette d\u00e9marche de r\u00e9solution de probl\u00e8mes et cette m\u00e9thodologie pour les d\u00e9composer en \u00e9tapes simples, c'est ce qu'en informatique on appelle l'algorithmique. \u00c9videmment \u00e7a peut s'appliquer \u00e0 bien d'autres sujets !", 
            "title": "Algori...quoi ?"
        }, 
        {
            "location": "/01-generalites/#une-question-decriture-et-de-representations", 
            "text": "Puisque dans un algorithme on trouve simplement des \u00e9tapes et des actions, il peut avoir plusieurs repr\u00e9sentations  :    un  algorigramme  : un diagramme d'\u00e9tapes successives repr\u00e9sent\u00e9 avec des rectangles, des bulles, des losanges et des fl\u00e8ches,   du  pseudo-code  : une \u00e9criture en quasi-fran\u00e7ais d\u00e9sambigu\u00efs\u00e9  du  code source  : une explication dans un langage informatique non-ambig\u00fc permettant \u00e0 l'ordinateur de le transformer en quelque chose qu'il comprends.  du  byte-code  : suite d'instructions binaires pour un logiciel interpr\u00e8te  du  code machine  : suite d'instructions binaires envoy\u00e9es au processeur et \u00e0 la m\u00e9moire.   L'algorigramme  et le  pseudo-code  sont l\u00e0 essentiellement pour des besoins \u00e9ducatifs, mais il existe d'autres formes de diagrammes qui sont \"normalis\u00e9s\" et permettent \u00e9galement de repr\u00e9senter des programmes. On parlera alors de repr\u00e9sentation UML, Merise, SDL, etc. Ces diff\u00e9rents langages graphiques  permettent d'avoir une description et d'organiser un projet informatique entre plusieurs intervenants de m\u00e9tiers diff\u00e9rents et leur permettre de communiquer.  Le  code machine  (ou binaire ex\u00e9cutable) c'est ce que la machine comprends \"en vrai\": c'est la suite d'op\u00e9rations que le processeur doit faire, et les diff\u00e9rents \u00e9tats de la m\u00e9moire \u00e0 lui faire manipuler. \nCe code machine est sp\u00e9cifique \u00e0 un mod\u00e8le de processeur donn\u00e9. Il est donc incompatible avec un autre mod\u00e8le de processeur!  Assez vite on se rend compte que c'est assez ingrat d'\u00e9crire un programme de cette fa\u00e7on l\u00e0 ! C'est pourtant comme cela qu'il faut \u00e9crire le premier programme sur un processeur donn\u00e9, afin qu'il s'allume et serve \u00e0 quelque chose.   Pour \u00e9viter d'avoir \u00e0 faire cela pour tout le reste des programmes, on invent\u00e9 les  compilateurs  : c'est \u00e0 dire des outils capables de prendre un autre programme, \u00e9crit dans un langage de programmation par un humain, et de les transcrire automatiquement en code machine, pour obtenir des binaires ex\u00e9cutables sans avoir \u00e0 les \u00e9crire soi-m\u00eame en code machine. On a donc du fabriquer un compilateur par langage de programmation... et par type de machine.  Il faut savoir que lorsqu'on a du code machine entre les mains, c'est tr\u00e8s compliqu\u00e9 (voire impossible) de revenir au code source de d\u00e9part... c'est comme essayer de retrouver les ingr\u00e9dients et le dosage pr\u00e9cis d'un plat rien qu'en le go\u00fbtant ! Il faut \u00eatre expert go\u00fbteur, expert cuisinier... et l\u00e0 encore, c'est dur ! Cette propri\u00e9t\u00e9 du code machine est \u00e9videmment une aubaine pour les gens qui veulent diffuser leur programme sans montrer son fonctionnement.  Malgr\u00e9 cela, il y a un hic ! L'auteur (ou l'\u00e9diteur) doivent compiler leur code source en binaire ex\u00e9cutable pour chaque nouvelle plate-forme mat\u00e9rielle qui voit le jour, sous peine de voit leur programme \u00eatre incompatible chez les usagers des nouvelles plates-formes ! Et \u00e7a n\u00e9cessite donc beaucoup de travail (et donc des co\u00fbts) !  L\u00e0 encore, des petits malins se sont dit qu'il \u00e9tait peut-\u00eatre plus pratique d'avoir un \"interpr\u00e8te\" ou  interpr\u00e9teur , c'est \u00e0 dire un programme binaire sp\u00e9cifique \u00e0 chaque machine, capable de lire du code source et de le transformer au fur et \u00e0 mesure en instructions pour le processeur. Ainsi, plus besoin de compilation, et le programme est compatible avec toutes les machines o\u00f9 se trouve un interpr\u00e9teur pour le langage dans lequel il est \u00e9crit !   Malheureusement, il y a deux soucis avec les interpr\u00e9teurs : transcrire \"\u00e0 la vol\u00e9e\" du code source, cela n\u00e9cessite du temps... Par cons\u00e9quent un interpr\u00e8te sera donc toujours plus lent qu'un programme binaire ex\u00e9cutable. En plus, pour utiliser un programme avec un interpr\u00e9teur il faut diffuser le code source du programme ! Autant \u00e7a ne g\u00e8ne pas les adeptes du partage, autant les gens voulant garder secrets leurs algorithmes n'ont pas trouv\u00e9 cela g\u00e9nial...  C'est l\u00e0 qu'est apparu le  byte-code . Le byte-code, c'est du code machine pour une machine \"virtuelle\", c'est \u00e0 dire une machine qui n'existe pas. Son code machine hypoth\u00e9tique serait minimaliste et transposable facilement sur n'importe quel processeur, avec moins d'efforts que pour un langage de programmation. L'id\u00e9e est ici de compiler quand le code source en du byte-code, et d'avoir un interpr\u00e9teur de byte-code sur chaque plate-forme.   Avec cette technique, on obtient une vitesse de fonctionnement raisonnable, une compatibilit\u00e9 avec toutes les machines qui poss\u00e8dent un interpr\u00e9teur bytecode et aucune fa\u00e7on de remonter au code source de d\u00e9part ! C'est la strat\u00e9gie utilis\u00e9e par Java ou .NET .   Bref. Lorsque l'on programme, on \u00e9crit donc en g\u00e9n\u00e9ral du  code source , dans un langage de programmation. Mais rien n'emp\u00eache de faire un diagramme pour se fixer les id\u00e9es ! \u00c7a arrive m\u00eame aux meilleurs professionnels apr\u00e8s plusieurs d\u00e9c\u00e9nies de pratique.", 
            "title": "Une question d'\u00e9criture et de repr\u00e9sentations"
        }, 
        {
            "location": "/01-generalites/#a-suivre", 
            "text": "Avant de continuer, j'ai besoin d'en savoir plus sur toi ! D\u00e9j\u00e0 parce que je suis curieux (eh oui !) et parce que \u00e7a me permettra d'adapter sur-mesure la suite du cours :   pourquoi est-ce que la technologie t'int\u00e9resse ?   comment est-ce que tu imagines le fait de coder ?   qu'est ce que tu imagines que cela peut t'apporter ?   Bref. Si tu veux la suite, envoie-moi un email avec le texte  \"JE VEUX LA SUITE !\"  dedans :-)", 
            "title": "\u00c0 suivre ?"
        }, 
        {
            "location": "/02-algorithmique/", 
            "text": "\ufeffG\u00e9n\u00e9ralit\u00e9s (suite)\n#\n\n\nTu es toujours l\u00e0 ? Toujours motiv\u00e9e ? Trop bien ! Reprenons ! \n\n\nUn travail \u00e0 vocation universelle\n#\n\n\nTu as vu dans le chapitre pr\u00e9c\u00e9dent que la programmation est l'art de m\u00ealer l'algorithmique \u00e0 un ou plusieurs langages\n\n\nL'algorithmique est juste une question de m\u00e9thode (beaucoup) et de logique (un peu). Par cons\u00e9quent, elle est \nind\u00e9pendante des langages\n de programmation et \nind\u00e9pendante des machines\n qui ex\u00e9cuteront le programme final. En revanche, le langage de programmation, lui, est li\u00e9 au cot\u00e9 physique et mat\u00e9riel de la machine car il doit \u00eatre compris et ex\u00e9cut\u00e9 par cette derni\u00e8re.\n\n\nOn a l'habitude de distinguer deux types de langages : \n\n\n\n\nles \nlangages bas niveau\n (ex: Assembleur, C ...) : ils permettent la manipulation des aspects mat\u00e9riels de la machine sur laquelle le programme est ex\u00e9cut\u00e9. Ce sont des langages terriblement terre \u00e0 terre, qui n\u00e9cessitent un micro-management de chaque chose : m\u00e9moire, p\u00e9riph\u00e9riques, registre processeur, interruptions, r\u00e9seau, etc. C'est \u00e0 la fois fastidieux, mais c'est terriblement pr\u00e9cis et puissant.\n\n\nles \nlangages de haut niveau\n (ex: Python, Javascript ...) : ils masquent le cot\u00e9 technique au profit d'une vision plus abstraite qui leur permettra plus facilement de manipuler des fichiers, des composants graphiques, des donn\u00e9es, etc. Ces langages font confiance au syst\u00e8me pour la gestion de la m\u00e9moire et du reste et vont s'occuper essentiellement des aspects m\u00e9tiers.\n\n\n\n\nHaut et bas niveau n'ont pas de connotation p\u00e9jorative et n'ont \u00e9videmment rien \u00e0 voir avec les comp\u00e9tences techniques n\u00e9cessaires \u00e0 les programmer ! Il s'agit simplement d'une question d'efficacit\u00e9 sur un domaine particulier... et la facilit\u00e9 \u00e0 g\u00e9rer contraintes qui vont avec. On pourra toujours faire des choses de bas niveau avec un langage de haut niveau, ou des choses de haut niveau avec un langage de bas niveau. C'est juste \nbeaucoup\n moins pratique.\n\n\nEn g\u00e9n\u00e9ral, les langages bas niveau seront des langages compil\u00e9s \n car d\u00e9pendants d'une machine sp\u00e9cifique \n et les langages de haut niveau seront des langages interpr\u00e9t\u00e9s. \n\n\nProbl\u00e8mes fondamentaux en algorithmique\n#\n\n\nProgrammer, c'est comme r\u00e9soudre un casse t\u00eate. C'est un peu un d\u00e9fi qui n\u00e9cessite d'inventer une solution face \u00e0 un probl\u00e8me ou une situation donn\u00e9e. Reste \u00e0 le faire bien. Lorsqu'on programme, \u00e0 un moment ou un autre, on se posera des questions sur la \ncalculabilit\u00e9\n, la \ncomplexit\u00e9\n ou la \ncorrection\n de l'algorithme que l'on est en train de concevoir.\n\n\nLa \ncalculabilit\u00e9\n est la capacit\u00e9 \u00e0 calculer un r\u00e9sultat ou une solution : Pour une t\u00e2che donn\u00e9e, existe-t-il un algorithme qui la r\u00e9solve ? Existe-t-il des t\u00e2ches pour lesquelles il n'existe aucun algorithme ? Comment savoir si l'on est dans l'un ou l'autre des cas ?\n\n\nLa \ncomplexit\u00e9\n est lie le nombre d'op\u00e9rations ex\u00e9cut\u00e9es par l'algorithme \u00e0 la taille ou la quantit\u00e9 des donn\u00e9es qu'il manipule. C'est donc une question de performance et d'optimisation : en combien de temps un algorithme va-t-il atteindre le r\u00e9sultat pr\u00e9vu ? De quel espace (m\u00e9moire) a-t-il besoin pour faire son travail ? \n\n\nLorsqu'on parle de complexit\u00e9, on utilise la notation \nO(...)\n pour parler des diff\u00e9rence de complexit\u00e9 d'un algorithme. Voici les principaux cas :\n\n\n\n\n\n\nO(1)\n : l'algorithme en temps constant. Il prends toujour le m\u00eame temps quel que soit la taille ou la quantit\u00e9 de donn\u00e9es qu'il manipule. C'est excellent !\n\n\n\n\n\n\nO(N)\n : l'algorithme en temps lin\u00e9aire (c'est bof). Il prends un temps proportionnel \u00e0 la quantit\u00e9 de donn\u00e9es manipul\u00e9es. C'est moyen.\n\n\n\n\n\n\nO(log N)\n : l'algorithme est en temps logarithmique (c'est bien), il prends moins de temps. C'est tr\u00e8s bien.\n\n\n\n\n\n\nO(N\nN\n..)\n : l'algorithme est en temps polynomial. Il prends un temps qui est le carr\u00e9, le cube ou autre polyn\u00f4me de la quantit\u00e9 de donn\u00e9es manipul\u00e9es. C'est pas terrible.\n\n\n\n\n\n\nO(exp(N))\n : l'algorithme est en temps exponentiel. C'est pire que tout : il y a de fortes chances que l'on n'obtienne pas les r\u00e9sultats dans un temps raisonnable (temps allou\u00e9 au projet, vie humaine, \u00e2ge de l'univers, etc.) ;-)\n\n\n\n\n\n\nEnfin la \ncorrection\n c'est pouvoir prouver qu'un algorithme r\u00e9pondre bien au besoin pour lequel il a \u00e9t\u00e9 con\u00e7u... et c'est loin d'\u00eatre \u00e9vident.\n\n\n\u00c0 suivre ?\n#\n\n\nJusque l\u00e0 j'ai pos\u00e9 un peu le contexte : c'\u00e9tait un peu de culture g\u00e9n\u00e9rale et du vocabulaire. Normalement on n'abordera plus ces sujets, \u00e0 moins que tu en aie envie.\n\n\nSi \u00e7a te botte toujours, au prochain chapitre on plongera dans les algorigrammes et on commencera \u00e0 dessiner nos id\u00e9es.\n\n\n\n\nEst-ce que \u00e7a va jusque l\u00e0 ? \n\n\nEn terme de volume, est ce que c'est trop long ? Trop court ?\n\n\nEst-ce que tu as des questions ou des trucs que tu as envie de dire ? :-P\n\n\n\n\nSi tu veux la suite, envoie-moi un e-mail avec le texte \n\"JE VEUX LA SUITE !\"\n :-)\n\n\n\n\nNote\n\n\nProgrammer peut entra\u00eener de graves d\u00e9formations comportementales.\n\nEn cas d'apparition des sympt\u00f4mes suivants : impossibilit\u00e9 de r\u00e9sister aux d\u00e9fis, envie de dialoguer avec son \u00e9cran, veill\u00e9e tardive, recherches compulsives sur StackOverflow, r\u00e9flexion nocturne sur un bug et apparition d'une solution au matin, dire \u00e0 quelqu'un qu'on arrive et arriver 1h apr\u00e8s, essayer d'automatiser la moindre t\u00e2che... alors il est trop tard, tu es foutue ;-)", 
            "title": "02. G\u00e9n\u00e9ralit\u00e9s (suite)"
        }, 
        {
            "location": "/02-algorithmique/#generalites-suite", 
            "text": "Tu es toujours l\u00e0 ? Toujours motiv\u00e9e ? Trop bien ! Reprenons !", 
            "title": "\ufeffG\u00e9n\u00e9ralit\u00e9s (suite)"
        }, 
        {
            "location": "/02-algorithmique/#un-travail-a-vocation-universelle", 
            "text": "Tu as vu dans le chapitre pr\u00e9c\u00e9dent que la programmation est l'art de m\u00ealer l'algorithmique \u00e0 un ou plusieurs langages  L'algorithmique est juste une question de m\u00e9thode (beaucoup) et de logique (un peu). Par cons\u00e9quent, elle est  ind\u00e9pendante des langages  de programmation et  ind\u00e9pendante des machines  qui ex\u00e9cuteront le programme final. En revanche, le langage de programmation, lui, est li\u00e9 au cot\u00e9 physique et mat\u00e9riel de la machine car il doit \u00eatre compris et ex\u00e9cut\u00e9 par cette derni\u00e8re.  On a l'habitude de distinguer deux types de langages :    les  langages bas niveau  (ex: Assembleur, C ...) : ils permettent la manipulation des aspects mat\u00e9riels de la machine sur laquelle le programme est ex\u00e9cut\u00e9. Ce sont des langages terriblement terre \u00e0 terre, qui n\u00e9cessitent un micro-management de chaque chose : m\u00e9moire, p\u00e9riph\u00e9riques, registre processeur, interruptions, r\u00e9seau, etc. C'est \u00e0 la fois fastidieux, mais c'est terriblement pr\u00e9cis et puissant.  les  langages de haut niveau  (ex: Python, Javascript ...) : ils masquent le cot\u00e9 technique au profit d'une vision plus abstraite qui leur permettra plus facilement de manipuler des fichiers, des composants graphiques, des donn\u00e9es, etc. Ces langages font confiance au syst\u00e8me pour la gestion de la m\u00e9moire et du reste et vont s'occuper essentiellement des aspects m\u00e9tiers.   Haut et bas niveau n'ont pas de connotation p\u00e9jorative et n'ont \u00e9videmment rien \u00e0 voir avec les comp\u00e9tences techniques n\u00e9cessaires \u00e0 les programmer ! Il s'agit simplement d'une question d'efficacit\u00e9 sur un domaine particulier... et la facilit\u00e9 \u00e0 g\u00e9rer contraintes qui vont avec. On pourra toujours faire des choses de bas niveau avec un langage de haut niveau, ou des choses de haut niveau avec un langage de bas niveau. C'est juste  beaucoup  moins pratique.  En g\u00e9n\u00e9ral, les langages bas niveau seront des langages compil\u00e9s   car d\u00e9pendants d'une machine sp\u00e9cifique   et les langages de haut niveau seront des langages interpr\u00e9t\u00e9s.", 
            "title": "Un travail \u00e0 vocation universelle"
        }, 
        {
            "location": "/02-algorithmique/#problemes-fondamentaux-en-algorithmique", 
            "text": "Programmer, c'est comme r\u00e9soudre un casse t\u00eate. C'est un peu un d\u00e9fi qui n\u00e9cessite d'inventer une solution face \u00e0 un probl\u00e8me ou une situation donn\u00e9e. Reste \u00e0 le faire bien. Lorsqu'on programme, \u00e0 un moment ou un autre, on se posera des questions sur la  calculabilit\u00e9 , la  complexit\u00e9  ou la  correction  de l'algorithme que l'on est en train de concevoir.  La  calculabilit\u00e9  est la capacit\u00e9 \u00e0 calculer un r\u00e9sultat ou une solution : Pour une t\u00e2che donn\u00e9e, existe-t-il un algorithme qui la r\u00e9solve ? Existe-t-il des t\u00e2ches pour lesquelles il n'existe aucun algorithme ? Comment savoir si l'on est dans l'un ou l'autre des cas ?  La  complexit\u00e9  est lie le nombre d'op\u00e9rations ex\u00e9cut\u00e9es par l'algorithme \u00e0 la taille ou la quantit\u00e9 des donn\u00e9es qu'il manipule. C'est donc une question de performance et d'optimisation : en combien de temps un algorithme va-t-il atteindre le r\u00e9sultat pr\u00e9vu ? De quel espace (m\u00e9moire) a-t-il besoin pour faire son travail ?   Lorsqu'on parle de complexit\u00e9, on utilise la notation  O(...)  pour parler des diff\u00e9rence de complexit\u00e9 d'un algorithme. Voici les principaux cas :    O(1)  : l'algorithme en temps constant. Il prends toujour le m\u00eame temps quel que soit la taille ou la quantit\u00e9 de donn\u00e9es qu'il manipule. C'est excellent !    O(N)  : l'algorithme en temps lin\u00e9aire (c'est bof). Il prends un temps proportionnel \u00e0 la quantit\u00e9 de donn\u00e9es manipul\u00e9es. C'est moyen.    O(log N)  : l'algorithme est en temps logarithmique (c'est bien), il prends moins de temps. C'est tr\u00e8s bien.    O(N N ..)  : l'algorithme est en temps polynomial. Il prends un temps qui est le carr\u00e9, le cube ou autre polyn\u00f4me de la quantit\u00e9 de donn\u00e9es manipul\u00e9es. C'est pas terrible.    O(exp(N))  : l'algorithme est en temps exponentiel. C'est pire que tout : il y a de fortes chances que l'on n'obtienne pas les r\u00e9sultats dans un temps raisonnable (temps allou\u00e9 au projet, vie humaine, \u00e2ge de l'univers, etc.) ;-)    Enfin la  correction  c'est pouvoir prouver qu'un algorithme r\u00e9pondre bien au besoin pour lequel il a \u00e9t\u00e9 con\u00e7u... et c'est loin d'\u00eatre \u00e9vident.", 
            "title": "Probl\u00e8mes fondamentaux en algorithmique"
        }, 
        {
            "location": "/02-algorithmique/#a-suivre", 
            "text": "Jusque l\u00e0 j'ai pos\u00e9 un peu le contexte : c'\u00e9tait un peu de culture g\u00e9n\u00e9rale et du vocabulaire. Normalement on n'abordera plus ces sujets, \u00e0 moins que tu en aie envie.  Si \u00e7a te botte toujours, au prochain chapitre on plongera dans les algorigrammes et on commencera \u00e0 dessiner nos id\u00e9es.   Est-ce que \u00e7a va jusque l\u00e0 ?   En terme de volume, est ce que c'est trop long ? Trop court ?  Est-ce que tu as des questions ou des trucs que tu as envie de dire ? :-P   Si tu veux la suite, envoie-moi un e-mail avec le texte  \"JE VEUX LA SUITE !\"  :-)   Note  Programmer peut entra\u00eener de graves d\u00e9formations comportementales. \nEn cas d'apparition des sympt\u00f4mes suivants : impossibilit\u00e9 de r\u00e9sister aux d\u00e9fis, envie de dialoguer avec son \u00e9cran, veill\u00e9e tardive, recherches compulsives sur StackOverflow, r\u00e9flexion nocturne sur un bug et apparition d'une solution au matin, dire \u00e0 quelqu'un qu'on arrive et arriver 1h apr\u00e8s, essayer d'automatiser la moindre t\u00e2che... alors il est trop tard, tu es foutue ;-)", 
            "title": "\u00c0 suivre ?"
        }
    ]
}